<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Array Cardio üí™</title>
</head>
<body>
  <p><em>Psst: have a look at the JavaScript Console</em> üíÅ</p>
  <script>
    // Get your shorts on - this is an array workout!
    // ## Array Cardio Day 1

    // Some data we can work with

    const inventors = [
      { first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 },
      { first: 'Isaac', last: 'Newton', year: 1643, passed: 1727 },
      { first: 'Galileo', last: 'Galilei', year: 1564, passed: 1642 },
      { first: 'Marie', last: 'Curie', year: 1867, passed: 1934 },
      { first: 'Johannes', last: 'Kepler', year: 1571, passed: 1630 },
      { first: 'Nicolaus', last: 'Copernicus', year: 1473, passed: 1543 },
      { first: 'Max', last: 'Planck', year: 1858, passed: 1947 },
      { first: 'Katherine', last: 'Blodgett', year: 1898, passed: 1979 },
      { first: 'Ada', last: 'Lovelace', year: 1815, passed: 1852 },
      { first: 'Sarah E.', last: 'Goode', year: 1855, passed: 1905 },
      { first: 'Lise', last: 'Meitner', year: 1878, passed: 1968 },
      { first: 'Hanna', last: 'Hammarstr√∂m', year: 1829, passed: 1909 }
    ];

    const people = [
      'Bernhard, Sandra', 'Bethea, Erin', 'Becker, Carl', 'Bentsen, Lloyd', 'Beckett, Samuel', 'Blake, William', 'Berger, Ric', 'Beddoes, Mick', 'Beethoven, Ludwig',
      'Belloc, Hilaire', 'Begin, Menachem', 'Bellow, Saul', 'Benchley, Robert', 'Blair, Robert', 'Benenson, Peter', 'Benjamin, Walter', 'Berlin, Irving',
      'Benn, Tony', 'Benson, Leana', 'Bent, Silas', 'Berle, Milton', 'Berry, Halle', 'Biko, Steve', 'Beck, Glenn', 'Bergman, Ingmar', 'Black, Elk', 'Berio, Luciano',
      'Berne, Eric', 'Berra, Yogi', 'Berry, Wendell', 'Bevan, Aneurin', 'Ben-Gurion, David', 'Bevel, Ken', 'Biden, Joseph', 'Bennington, Chester', 'Bierce, Ambrose',
      'Billings, Josh', 'Birrell, Augustine', 'Blair, Tony', 'Beecher, Henry', 'Biondo, Frank'
    ];
    
    // Array.prototype.filter()
    // 1. Filter the list of inventors for those who were born in the 1500's

    /* function between (year, min, max){
      return year => min && year <= max;
    }

    if (between(year, 1500, 1600)){
      for (var i in a){
        console.log("row" + i);
        for (var j in a[i])
        {
          console.log(" " + a[i][j])
        }
      }
    }
    */
    let inventorBirths = inventors.filter( //created a variable called inventorBirths and assigned it to the inventors array and put the .filter function on it to filter what we need from the array
      inventor => inventor.year >= 1500 && inventor.year <= 1600); // this fat arrow function says to take a singular inventor and check if their year value is greater than 1500 and less than 1600, and if true, adds it to the "inventorBirths" var which is an array because .filter makes it an array
    console.log(inventorBirths); //logs to console
    
    // Array.prototype.map()
    // 2. Give us an array of the inventors first and last names

 let inventorNames = inventors.map(inventor => { //creates var "inventorNames" and assigns inventors.map to it, thus making inventorNames an array and begins the .map function
  return inventor.first + " " + inventor.last;
}) //this returns inventor.first and inventor.last to inventor.names. This is directly referencing the inventors array since we are calling .map on inventors, but we are assigning "inventor" as a "singular" argument to use to return items back to inventorNames for the array, by calling inventor.first (which is "first" in the inventors array) and inventor.last (which is "last" in the inventors array).

console.log(inventorNames); 
//logs inventorNames to console

//ebiggz says: map loops through every item in the array and calls the function you provide it. It replaces the item at the current index with whatever new value your function returns. so in that case, it loops through the inventor array and builds a new array with first + last strings in place of the inventors // again, its "mapping" the item in the array to some other value. Hence the name.


    // Array.prototype.sort()
    // 3. Sort the inventors by birthdate, oldest to youngest

//created an inventorsSorted variable which gets an array assigned to it via .sort  and we declare the arguments of sort to be the comparison values inventorA and inventorB (top line of below code)
let inventorsSorted = inventors.sort((inventorA, inventorB) => inventorA.year - inventorB.year); 
// then we fat arrow function inventorA and minus that from inventorB to get the correct order of inventors in the inventorsSorted array. (bottom line of above code)

console.log(inventorsSorted); 
//console logging inventorsSorted




    // Array.prototype.reduce()
    // 4. How many years did all the inventors live all together?

    //let inventorsTotal = "";
    let reducer = (accumulator, inventor) => accumulator + (inventor.passed - inventor.year)

    console.log(inventors.reduce(reducer, 0))

    // 5. Sort the inventors by years lived

    let inventorsByAge = inventors.sort((inventorA, inventorB) => {
    let aAge = inventorA.passed - inventorA.year;
    let bAge = inventorB.passed - inventorB.year;
    return aAge - bAge;
});

  console.log(inventorsByAge)

//EBIGGZ SAYS: if that returns 0, that means a and b are equal. of its greater than 0, it means a is greater than b, if its less than 0 (negative), b is greater than a


    // 6. create a list of Boulevards in Paris that contain 'de' anywhere in the name
    // https://en.wikipedia.org/wiki/Category:Boulevards_in_Paris

  //const category = document.querySelector('.mw-category');
  //const links = Array.from(category.querySelectorAll('a'));
  //const de = links.map(link => link.textContent).filter(streetName => streetName.includes('de'));
  //this creates a var called category, and queries the .mw-category div for the information inside the div
  
  //this creates a links variable that uses Array.from to select all the anchor links on the page ('a') and converts the list (since everything that gets selected is a NodeList, we have to turn the NodeList into an array using Array.from) and that selects all of the elements in 'category' which is all of the links, and turns it into an array instead of a NodeList so we can use array functions.

  //ASK BIGGZ: would category.querySelectorAll('a')); be mw-category or how does this work? I generally get it but still.
  
    //This is making a variable called 'de' and taking the links array we made earlier and mapping over each item in the array which is the links, and taking the text content of the links, and then filtering the 'streetName' out to see if the current array item includes the characters (word or characters?) 'de' and returns them as an array as 'de' when 'de' is called in the console.

    // 7. sort Exercise
    // Sort the people alphabetically by last name

  const nameSort = people.sort();

  console.log(nameSort);


    // 8. Reduce Exercise
    // Sum up the instances of each of these
    const data = ['car', 'car', 'truck', 'truck', 'bike', 'walk', 'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck' ];

    const wordCounts = data.reduce(function(obj, word){
      if (!obj[word]) {
        //if the word doesn't yet exist as a property of the accumulator object,
        //add it as a property and set its count to 1
        //Setari: We create a variable to hold the .reduce information from reducing the data array, and introduce declare obj and word as arguments to use in the reduce function args.
        // in the args, obj is the accumulator, and word is the current value that reduce is looking at (?).
        //the if says if the object is NOT a property of the accumulator object (meaning it's not in the array obj is holding which on the first pass is blank) (?) to add the 'word' it's looking at and set the count to 1 as seen below
        obj[word] = 1;
      } else {
        //word exists, increment its count
        //Setari: Here we have an else that says else, if the object has that word inside of the current "fake" array it's holding, to add 1 to the value of the word to "count" it.
        obj[word]++
      }
      return obj; // return the modified object to be used as an accumulator in the next iteration
    }, {}); //initialize the accumulator as an empty object

console.log(wordCounts); //console.logs the output of wordCounts, which ends up being:
/* 
bike: 2
car: 5
truck: 3
van: 2
walk: 2 
*/

  </script>
</body>
</html>
